<#@ template debug="false" hostspecific="false" language="c#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".fx" #>
//-----------------------------------------------------
//         Autogenerated code - DO NOT EDIT -
//         Edit VertexShadersCode.tt and save.
//-----------------------------------------------------

#include "PBR.fx"
#include "VertexShadersStructs.fx"
#include "VertexShadersCode.fx"

<#

const int PIXELPERMUTATIONS = 32; // replaced with 64 to add the IBL permutation

string JoinBools(params bool[] values)
{
    return String.Join(", ", values.Select(item=>item.ToString().ToLower()));
}

var psShaders = new List<string>(); // store pixel shader definitions here

for(int psIdx=0; psIdx < PIXELPERMUTATIONS; ++psIdx)
{
    var PSSHADER = "Ps";

    var hasNormalsMap =(psIdx & 1) != 0;
    var hasPrimaryMap =(psIdx & 2) != 0;
    var hasSecondaryMap =(psIdx & 4) != 0;
    var hasEmissiveMap =(psIdx & 8) != 0;
    var hasOpacityMap =(psIdx & 16) != 0;
    var hasIBLightMap =(psIdx & 32) != 0;
    
    if (hasNormalsMap) PSSHADER += "_N";
    if (hasPrimaryMap) PSSHADER += "_A";
    if (hasSecondaryMap) PSSHADER += "_B";
    if (hasEmissiveMap) PSSHADER += "_E";
    if (hasOpacityMap) PSSHADER += "_O";
    if (hasIBLightMap) PSSHADER += "_IBL";

    psShaders.Add(PSSHADER);

#>

float4 <#=PSSHADER#>_PShader(VsOutTexNorm input) : COLOR0
{
	return PsShader(input, <#= JoinBools(hasNormalsMap,hasPrimaryMap,hasSecondaryMap,hasEmissiveMap,hasOpacityMap) #>);
}

<# } #>

// Technique Index =
//   Bit0 : Rigid / Skinned
//   Bit1 : VertexTangents+NormalMap
//   Bit2 : \
//           0=Color, 1=UV0, 2=Color+UV0, 3=Color+UV0+UV1
//   Bit3 : /

//   Bit4 : Primary Texture
//   Bit5 : Secondary Texture
//   Bit6 : Emissive Texture
//   Bit7 : Opacity Texture
//   Bit8 : IBL Light

// Notice that enabling vertex shader tangent normals also enables Normal Texture

<#

int techniqueIndex = 0;

for(int psIdx=0; psIdx < psShaders.Count; psIdx+=2)
{
    var vsMatPermutations = new [] {0,1,2,3};
    var vsSrfPermutations = new [] {1,2};

    foreach(int vsMat in vsMatPermutations)
    {
        // vertex material permutations
        // 0 - color
        // 1 - uv0
        // 2 - color + uv0
        // 3 - color + uv0 + uv1

        var HASCOLOR = vsMat != 1;
        var HASTXUV0 = vsMat != 0;
        var HASTXUV1 = vsMat == 3;

        foreach(int vsSrf in vsSrfPermutations)
        {
            // vertex surface permutations
            // 0 - nothing (used by Unlit shaders)
            // 1 - normal
            // 2 - normal + tangent        

            var HASNORMAL = vsSrf != 0;
            var HASTANGENT = vsSrf >= 2;

            // define vertex shader name

            var vsName = string.Empty;

            if (HASNORMAL) vsName +="_N";
            if (HASTANGENT) vsName +="T";        
    
            if (HASCOLOR) vsName +="_C1";
            if (HASTXUV0 && !HASTXUV1) vsName +="_UV1";
            if (HASTXUV0 && HASTXUV1) vsName +="_UV2";

            var RIGIDVERTEX = "VsInRigid" + vsName;
            var SKINNEDVERTEX = "VsInSkinned" + vsName;

            var PSSHADER = psShaders[psIdx + (HASTANGENT?1:0) ];
#>

// <#= techniqueIndex*2+0 #>
TECHNIQUE(<#=RIGIDVERTEX#>_<#=PSSHADER#>, <#=RIGIDVERTEX#>_VShader, <#=PSSHADER#>_PShader );

// <#= techniqueIndex*2+1 #>
TECHNIQUE(<#=SKINNEDVERTEX#>_<#=PSSHADER#>, <#=SKINNEDVERTEX#>_VShader, <#=PSSHADER#>_PShader );

<# ++techniqueIndex; } } } #>




