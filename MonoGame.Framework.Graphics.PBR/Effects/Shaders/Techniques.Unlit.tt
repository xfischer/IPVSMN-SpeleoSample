<#@ template debug="false" hostspecific="false" language="c#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".fx" #>
//-----------------------------------------------------
//         Autogenerated code - DO NOT EDIT -
//         Edit VertexShadersCode.tt and save.
//-----------------------------------------------------

#include "Unlit.fx"
#include "VertexShadersStructs.fx"
#include "VertexShadersCode.fx"

<#

const int PIXELPERMUTATIONS = 8;

string JoinBools(params bool[] values)
{
    return String.Join(", ", values.Select(item=>item.ToString().ToLower()));
}

var psShaders = new List<string>(); // store pixel shader definitions here

for(int psIdx=0; psIdx < PIXELPERMUTATIONS; ++psIdx)
{
    var PSSHADER = "Ps";

    var hasPrimary =(psIdx & 1) != 0;
    var hasEmissive =(psIdx & 2) != 0;
    var hasOpacity =(psIdx & 4) != 0;

    if (hasPrimary) PSSHADER += "Primary";
    if (hasEmissive) PSSHADER += "Emissive";
    if (hasOpacity) PSSHADER += "Opacity";

    psShaders.Add(PSSHADER);
#>

float4 <#=PSSHADER#>_PShader(VsOutTexNorm input) : COLOR0
{
	return PsShader(input, <#= JoinBools(hasPrimary,hasEmissive,hasOpacity) #>);
}

<# } #>

// Technique Index =
//   Bit0 : Rigid / Skinned
//   Bit1 : \
//           0=Color, 1=UV0, 2=Color+UV0, 3=Color+UV0+UV1
//   Bit2 : /
//   Bit3 : Primary Texture
//   Bit4 : Emissive
//   Bit5 : Opacity

<#

int techniqueIndex = 0;

for(int psIdx=0; psIdx < psShaders.Count; ++psIdx)
{
    var PSSHADER = psShaders[psIdx];

    var vsMatPermutations = new [] {0,1,2,3};
    var vsSrfPermutations = new [] {0};

    foreach(int vsMat in vsMatPermutations)
    {
        // vertex material permutations
        // 0 - color
        // 1 - uv0
        // 2 - color + uv0
        // 3 - color + uv0 + uv1

        var HASCOLOR = vsMat != 1;
        var HASTXUV0 = vsMat != 0;
        var HASTXUV1 = vsMat == 3;

        foreach(int vsSrf in vsSrfPermutations)
        {
            // vertex surface permutations
            // 0 - nothing (used by Unlit shaders)
            // 1 - normal
            // 2 - normal + tangent        

            var HASNORMAL = vsSrf != 0;
            var HASTANGENT = vsSrf >= 2;

            // define vertex shader name

            var vsName = string.Empty;

            if (HASNORMAL) vsName +="_N";
            if (HASTANGENT) vsName +="T";        
    
            if (HASCOLOR) vsName +="_C1";
            if (HASTXUV0 && !HASTXUV1) vsName +="_UV1";
            if (HASTXUV0 && HASTXUV1) vsName +="_UV2";

            var RIGIDVERTEX = "VsInRigid" + vsName;
            var SKINNEDVERTEX = "VsInSkinned" + vsName;
#>

// <#= 0 + vsMat * 2 + psIdx * 2 * 4 #>
TECHNIQUE(<#=RIGIDVERTEX#>_<#=PSSHADER#>, <#=RIGIDVERTEX#>_VShader, <#=PSSHADER#>_PShader );

// <#= 1 + vsMat * 2 + psIdx * 2 * 4 #>
TECHNIQUE(<#=SKINNEDVERTEX#>_<#=PSSHADER#>, <#=SKINNEDVERTEX#>_VShader, <#=PSSHADER#>_PShader );

<# ++techniqueIndex; } } } #>




